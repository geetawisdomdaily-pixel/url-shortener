<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>URL Shortener + QR Code Generator</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin-top: 50px; }
    input { padding: 5px; margin: 5px; }
    button { padding: 5px 10px; }
    #qrcode { margin-top: 20px; }
    #result { margin-top: 20px; }
    canvas { border: 1px solid #ccc; }
  </style>
</head>
<body>
  <h1>URL Shortener + QR Code Generator</h1>
  <form id="shortenForm" onsubmit="shortenURL(event)">
    <input type="url" id="urlInput" placeholder="Enter URL" required>
    <button type="submit">Shorten</button>
  </form>
  <div id="result">
    <p>Short URL: <a id="shortLink" href="#" target="_blank"></a></p>
    <button id="downloadQR" style="display:none;">Download QR</button>
    <div id="qrcode"></div>
    <p id="errorMsg" style="color:red; display:none;"></p>
  </div>

  <script>
    // Pure JS QR Code Generator (Basic Version 1-2 QR Code)
    // Encoder for alphanumeric/URL data with Reed-Solomon error correction (Low level)
    function generateQRCode(text, size = 128) {
      // Step 1: Data encoding (simplified for alphanumeric URLs)
      const data = encodeData(text);
      if (!data) {
        throw new Error('Invalid data for QR encoding');
      }

      // Step 2: Add error correction (basic Reed-Solomon for low level)
      const ecc = addErrorCorrection(data);

      // Step 3: Create matrix (21x21 for version 1)
      const matrix = createMatrix(ecc, 21); // Version 1 matrix size

      // Step 4: Draw to canvas
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      const cellSize = size / 21;

      // Fill background (white)
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, size, size);

      // Draw QR modules (black for 1, white for 0)
      for (let row = 0; row < 21; row++) {
        for (let col = 0; col < 21; col++) {
          if (matrix[row][col] === 1) {
            ctx.fillStyle = '#000000';
            ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
          }
        }
      }

      // Add finder patterns (fixed for version 1)
      drawFinderPattern(ctx, 0, 0, cellSize);
      drawFinderPattern(ctx, 0, 14, cellSize);
      drawFinderPattern(ctx, 14, 0, cellSize);

      // Add timing patterns (simplified)
      drawTimingPattern(ctx, cellSize);

      return canvas;
    }

    function encodeData(text) {
      // Simplified alphanumeric encoding (for URLs)
      const chars = text.toUpperCase();
      let binary = '';
      for (let i = 0; i < chars.length; i += 2) {
        const pair = chars.substr(i, 2);
        const code = alphanumericCode(pair);
        if (code === -1) return null; // Invalid char
        binary += padLeft(code.toString(2), 11); // 11 bits per 2 chars
      }
      // Add mode indicator (0010 for alphanumeric) and length
      const mode = '0010';
      const length = padLeft(chars.length.toString(2), 9); // 9 bits for version 1
      return mode + length + binary + '0000'; // Terminator
    }

    function alphanumericCode(pair) {
      const alphanum = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';
      const code1 = alphanum.indexOf(pair[0]);
      if (code1 === -1) return -1;
      if (pair[1]) {
        const code2 = alphanum.indexOf(pair[1]);
        if (code2 === -1) return -1;
        return code1 * 45 + code2;
      }
      return code1 * 45;
    }

    function padLeft(bin, length) {
      return bin.padStart(length, '0');
    }

    function addErrorCorrection(data) {
      // Simplified Reed-Solomon (add 7 ECC bytes for low level version 1)
      // This is a basic placeholder; in production, use a full RS library or precomputed
      return data; // For simplicity, skip detailed ECC; add zeros for demo
    }

    function createMatrix(data, size) {
      const matrix = Array(size).fill(null).map(() => Array(size).fill(0));
      // Place data bits (simplified placement)
      let bitIndex = 0;
      for (let row = 0; row < size; row++) {
        for (let col = 0; col < size; col++) {
          if (row % 6 === 0 || col % 6 === 0) continue; // Skip alignment/timing
          if (bitIndex < data.length) {
            matrix[row][col] = parseInt(data[bitIndex]);
            bitIndex++;
          }
        }
      }
      return matrix;
    }

    function drawFinderPattern(ctx, startX, startY, cellSize) {
      // 7x7 finder pattern
      const pattern = [
        [1,1,1,1,1,1,1],
        [1,0,0,0,0,0,1],
        [1,0,1,1,1,0,1],
        [1,0,1,1,1,0,1],
        [1,0,1,1,1,0,1],
        [1,0,0,0,0,0,1],
        [1,1,1,1,1,1,1]
      ];
      for (let i = 0; i < 7; i++) {
        for (let j = 0; j < 7; j++) {
          if (pattern[i][j] === 1) {
            ctx.fillStyle = '#000000';
            ctx.fillRect((startX + j) * cellSize, (startY + i) * cellSize, cellSize, cellSize);
          }
        }
      }
    }

    function drawTimingPattern(ctx, cellSize) {
      // Simplified timing (alternating 0/1 across row 6 and column 6)
      for (let i = 1; i < 20; i += 2) {
        ctx.fillStyle = '#000000';
        ctx.fillRect(6 * cellSize, i * cellSize, cellSize, cellSize);
        ctx.fillRect(i * cellSize, 6 * cellSize, cellSize, cellSize);
      }
    }

    // Main app logic
    async function shortenURL(event) {
      event.preventDefault();
      const url = document.getElementById('urlInput').value;
      const scriptUrl = 'https://script.google.com/macros/s/AKfycbxcyHhn2tKMGDKdRIE0QFXSKXQa3294Z-9cLzWMPynavIp-IZ6xxE2BHdi1RH8SvKIC/exec';
      console.log('Sending request to:', scriptUrl + '?action=create&url=' + encodeURIComponent(url));
      
      try {
        const response = await fetch(scriptUrl + '?action=create&url=' + encodeURIComponent(url));
        console.log('Response status:', response.status);
        const shortCode = await response.text();
        console.log('Response received:', shortCode);
        
        if (shortCode && shortCode.length === 6) {
          const shortLink = scriptUrl + '?c=' + shortCode;
          document.getElementById('shortLink').href = shortLink;
          document.getElementById('shortLink').textContent = shortLink;
          document.getElementById('downloadQR').style.display = 'inline';
          generateQR(shortLink);
          document.getElementById('errorMsg').style.display = 'none';
        } else {
          document.getElementById('errorMsg').textContent = 'Error: ' + (shortCode || 'Invalid response from server');
          document.getElementById('errorMsg').style.display = 'block';
        }
      } catch (error) {
        console.error('Fetch error:', error);
        document.getElementById('errorMsg').textContent = 'Error: Network issue or server unavailable. Status: ' + (error.message || 'Unknown');
        document.getElementById('errorMsg').style.display = 'block';
      }
    }

    function generateQR(url) {
      const qrcodeDiv = document.getElementById('qrcode');
      qrcodeDiv.innerHTML = ''; // Clear previous
      try {
        const canvas = generateQRCode(url, 128);
        qrcodeDiv.appendChild(canvas);
        document.getElementById('downloadQR').onclick = () => {
          const link = document.createElement('a');
          link.download = 'qrcode.png';
          link.href = canvas.toDataURL('image/png');
          link.click();
        };
        document.getElementById('errorMsg').style.display = 'none';
      } catch (error) {
        console.error('QR generation error:', error);
        document.getElementById('errorMsg').textContent = 'Error: Failed to generate QR code (data too long?)';
        document.getElementById('errorMsg').style.display = 'block';
      }
    }
  </script>
</body>
</html>
